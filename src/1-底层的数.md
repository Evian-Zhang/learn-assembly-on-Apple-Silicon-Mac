# 底层的数

在正式介绍汇编语言之前，我会先用几篇文章讲一些数学基础和硬件基础。如果读者已经具备了一定的知识基础，可以直接跳过这些文章去汇编语言部分。这一篇文章中，我将主要讨论“数”这一概念在底层的体现。

## 数的表示

在计算机底层的软件层面，我们通常采用二进制，八进制或十六进制来记录数字，其中最常用的是十六进制。所谓\\(n\\)进制，就是从0开始数，逢\\(n\\)进1. 比如说二进制，就是从0开始数，到1，然后到2的时候进1变成10. 八进制也是类似，但是到了十六进制就犯了难，我们的数字只有0到9这十个，并不能表示出16个呀，于是，我们默认使用了a到f这六个字母来分别表示10到15这六个数。也就是说，十进制数10对应的十六进制数是a, 十进制数26对应的十六进制数是1a. 在大部分计算机术语中，我们通常用`0x`开头表示十六进制，用`0`开头表示八进制，而没有前缀来表示十进制。因此，比如说以下的汇编代码（并不需要理解实际含义）

```armasm
sub	sp, sp, #0x1a
```

与

```armasm
sub	sp, sp, #26
```

的效果相同。

十进制数与十六进制数的转化可以在搜索引擎上找到，这里不再赘述。而八进制，十六进制数与二进制数的转换则十分简单。一个八进制数的一位代表一个二进制数的三位，比如说八进制数的一位`5`就代表二进制数的三位`011`; 同理，一个十六进制数的一位就代表二进制数的四位。因此，十六进制数`0x2000001`就代表二进制数`0010000000000000000000000001`.

我们知道，之所以使用二进制数，是因为计算机底层采用高电平/低电平这种方法来表示数。那么，我们为什么要使用八进制、十六进制呢？我们知道，如今的计算机大多采用64位系统，意思是说，任何一个地址都是一个64位二进制数。那么，如果我们只采用二进制来表示一个地址，那么得有64个`0`或者`1`, 这不仅让我们看花眼了，而且也极大的浪费了电脑的显示资源。而刚才讲到的十六进制数则帮我们解决了这个问题。我们知道，十六进制数的一位对应二进制数的4位。因此，一个\\(n\\)位二进制数，只需要\\(\lceil\frac{n}{4}\rceil\\)位十六进制数即可。也就是说，我们要表示64位的地址，只需要16位十六进制数即可。

## 整数的记录

进制问题解决了在计算机底层软件中数的表示问题，接下来还需要解决的是记录问题，也就是说，如何把数实际存储在寄存器中（下面以8位寄存器为例）。

一个最直观的想法，就是这个数是多少，就把它的二进制数存进寄存器中。例如，对于十进制数154，我们就在寄存器中存储二进制数`10011010`。这样，我们寄存器中可以存储的数的范围就是\\(0\sim 2^{8}-1\\)。

### 原码

但是，我们在日常的编程中，往往需要用到负数。按我们上面的做法，是没有办法存储这种符号信息的。解决这个问题，我们第一个想到的就是在这寄存器的8个位中，取一个位表示符号。例如，我们可以取最高位表示符号，1表示负数，0表示整数。那么，`10011010`就表示负的二进制数`11010`，也就是-26。在这种情况下，我们寄存器中可以存储的数的范围就是\\(-2^{7}+1\sim 2^{7}-1\\)。这种方式我们称作“原码”存储方式。

那么，所有整数都按上述方法用原码存储可以吗？我们知道，在编程中虽然会用到负数，但也会有许多情况只用到非负数（例如取数组下标的时候）。那么，如果用原码存储，我们只能用到\\(0\sim 2^{7}-1\\)这么多非负整数，比我们第一种不存储符号的方法少了接近一半可以用的数字，这让我们非常难以忍受。因此，我们需要提出一个共识：有符号整数与无符号整数共存！有符号整数，就是指其存储时包含了符号信息，就我们刚才所提出的方案来看，就是最高位存储符号；无符号整数则相反，其存储不包含符号信息，也就是我们提出的第一个方案，是多少就存多少，只能表示\\(0\sim 2^{8}-1\\)。

如果按原码存储有符号整数的方案，我们来考虑以下场景。寄存器A中存储了二进制数`11100001`，寄存器B中存储了二进制数`00000111`。按我们目前提到的方案来看，如果要计算加减，会变成这样：

* 如果A和B存储的是有符号数

   A存储十进制数-97，B存储十进制数7。A与B相加为-90，二进制数为`11011010`；A与B相减为-104，二进制数为`11101000`。
* 如果A和B存储的是无符号数

   A存储十进制数225，B存储十进制数7。A与B相加为232，二进制数为`11101000`；A与B相减为217，二进制数为`11011010`。

我们的CPU如果需要同时支持有符号数和无符号数的加减法，我们会发现，有符号数的加法与无符号数的减法得到的存储结果一致，反之亦然。如果按这种设计，我们需要在实现加法的时候首先判断是否有无符号，其次我们得同时实现加法器和减法器。

有没有更好的方法？

### 补码

我们来看看天才般的先行者是怎么做的。

下面，我们用\\(\alpha=f(a)\\)表示将整数\\(a\\)记录到寄存器中，其中寄存器的值直接转化成无符号二进制数为\\(\alpha\\)。例如，按照我们之前的说法，`10011010`就表示负的二进制数`11010`，也就是-26，那么，\\(f(-26)=154\\)，因为`10011010`直接转化为无符号二进制数就是154。

那么，我们之前讲的对于无符号整数的记录方法就很直接：

$$
\alpha =f_u(a)=a
$$

我们该如何记录有符号整数呢？

首先，我们需要指出，由于寄存器的位数是有限的，因此对于一个\\(n\\)位寄存器来说，如果

$$
f(a)\equiv f(b)\pmod{2^{n}}
$$

那么\\(a\\)和\\(b\\)存储到寄存器中时，是没法看出差别的（因为它们在寄存器中的表现是相同的），也就是说，可以认为$a=b$。

我们天才般的先行者提出了**补码**的概念，对于有符号整数的记录：

$$
\alpha =f_s(a)=\begin{cases}
a&0\leq a\leq 2^{n-1}-1\\\\
2^{n}+a&-2^{n-1}\leq a<0
\end{cases}
$$

容易验证，对于两个寄存器中的值\\(\alpha=f_u(a_u)=f_s(a_s)\\)和\\(\beta=f_u(b_u)=f_s(b_s)\\)，我们有：

对于无符号加法：

$$
f_u(a_u+b_u)\equiv f_u(a_u)+f_u(b_u)=\alpha+\beta\pmod{2^{n}}
$$

对于有符号加法：

$$
f_s(a_s+b_s)\equiv f_s(a_s)+f_u(b_s)=\alpha+\beta\pmod{2^{n}}
$$

对于无符号减法：

$$
f_u(a_u-b_u)\equiv f_u(a_u)+f_s(-b_u)\pmod{2^{n}}
$$

对于有符号减法：

$$
f_s(a_s-b_s)\equiv f_s(a_s)+f_s(-b_s)\pmod{2^{n}}
$$

还是以我们之前的场景为例。寄存器A中存储了二进制数`11100001`，寄存器B中存储了二进制数`00000111`。按补码方案来看：

* 如果A和B存储的是有符号数

   A存储十进制数-31，B存储十进制数7。
   
   A与B相加为-24，其补码为`11101000`，正好就是`11100001+00000111=11101000`。
   
   A与B相减为-38，其补码为`11011010`。其计算方法为，先求-7的补码，为`11111001`，然后再直接相加`11100001+11111001=11011010`。
* 如果A和B存储的是无符号数

   A存储十进制数225，B存储十进制数7。
   
   A与B相加为232，在寄存器中为`11101000`，正好就是`11100001+00000111=11101000`。
   
   A与B相减为218，在寄存器中为`11011010`。其计算方法为，先求-7的补码，为`11111001`，然后再直接相加`11100001+11111001=11011010`。

由此可见，在这种方法下，无论将寄存器中的值看作有符号数还是无符号数，其加法与减法都只需经历相同的运算，并且得到的结果在寄存器中相同。也就是说，我们只需要实现一个加法器（以及一个求补码的器件），就可以实现所有有符号数与无符号数的加减法了。

提到有符号整数与无符号整数，有一句看似很有哲理的话：“存储在存储器中的数本没有有无符号的差别，只是若干高低电平。只有在操作它们的时候，它们才有了自己的符号。”理解这句话，对进一步深入编程底层很有帮助。举个例子，我们有一个8位的寄存器，其内容为二进制数`10001111`。这个寄存器内的数有符号吗？答案是它不含符号信息。它既可以是有符号整数`-0x71`，也可以是无符号整数`+0x8f`。只有在CPU对这个寄存器进行操作的时候，相应的值才会产生符号信息。例如，

## 逻辑运算

除了加减乘除以外，二进制数还有独特的运算——逻辑运算。分别是与(and), 或(or), 非(not)和异或(xor). 与或非大家都很熟悉了，异或就是当且仅当两个操作数不同时输出`1`, 相同时输出`0`.
