# 数学基础

在正式介绍汇编语言之前，我会先用几篇文章讲一些数学基础和硬件基础。如果读者已经具备了一定的知识基础，可以直接跳过这些文章去汇编语言部分。

## 二进制，八进制与十六进制

在计算机底层的软件层面，我们通常采用二进制，八进制或十六进制来记录数字，其中最常用的是十六进制。所谓\\(n\\)进制，就是从0开始数，逢\\(n\\)进1. 比如说二进制，就是从0开始数，到1，然后到2的时候进1变成10. 八进制也是类似，但是到了十六进制就犯了难，我们的数字只有0到9这十个，并不能表示出16个呀，于是，我们默认使用了a到f这六个字母来分别表示10到15这六个数。也就是说，十进制数10对应的十六进制数是a, 十进制数26对应的十六进制数是1a. 在大部分计算机术语中，我们通常用`0x`开头表示十六进制，用`0`开头表示八进制，而没有前缀来表示十进制。因此，比如说以下的汇编代码（并不需要理解实际含义）

```armasm
sub	sp, sp, #0x1a
```

与

```armasm
sub	sp, sp, #26
```

的效果相同。

十进制数与十六进制数的转化可以在搜索引擎上找到，这里不再赘述。而八进制，十六进制数与二进制数的转换则十分简单。一个八进制数的一位代表一个二进制数的三位，比如说八进制数的一位`5`就代表二进制数的三位`011`; 同理，一个十六进制数的一位就代表二进制数的四位。因此，十六进制数`0x2000001`就代表二进制数`0010000000000000000000000001`.

我们知道，之所以使用二进制数，是因为计算机底层采用高电平/低电平这种方法来表示数。那么，我们为什么要使用八进制、十六进制呢？我们知道，如今的计算机大多采用64位系统，意思是说，任何一个地址都是一个64位二进制数。那么，如果我们只采用二进制来表示一个地址，那么得有64个`0`或者`1`, 这不仅让我们看花眼了，而且也极大的浪费了电脑的显示资源。而刚才讲到的十六进制数则帮我们解决了这个问题。我们知道，十六进制数的一位对应二进制数的4位。因此，一个\\(n\\)位二进制数，只需要\\(\lceil\frac{n}{4}\rceil\\)位十六进制数即可。也就是说，我们要表示64位的地址，只需要16位十六进制数即可。

## 补码

进制问题解决了在计算机底层软件中数的表示问题，接下来还需要解决的是记录问题，也就是说，如何把数实际存储在寄存器中（下面以8位寄存器为例）。

一个最直观的想法，就是这个数是多少，就把它的二进制数存进寄存器中。例如，对于十进制数154，我们就在寄存器中存储二进制数`10011010`。这样，我们寄存器中可以存储的数的范围就是\\(0\sim 2^{8}-1\\)。

但是，我们在日常的编程中，往往需要用到负数。按我们上面的做法，是没有办法存储这种符号信息的。解决这个问题，我们第一个想到的就是在这寄存器的8个位中，取一个位表示符号。例如，我们可以取最高位表示符号，1表示负数，0表示整数。那么，`10011010`就表示负的二进制数`11010`，也就是-26。在这种情况下，我们寄存器中可以存储的数的范围就是\\(-2^{7}+1\sim 2^{7}-1\\)。

那么，所有整数都按上述方法存储可以吗？我们知道，在编程中虽然会用到负数，但也会有许多情况只用到非负数（例如取数组下标的时候）。那么，如果按上述方法存储，我们只能用到\\(0\sim 2^{7}-1\\)这么多非负整数，比我们第一种方法少了接近一半。这让我们非常难以忍受。因此，我们需要提出一个共识：有符号整数与无符号整数共存！有符号整数，就是指其存储时包含了符号信息，就我们刚才所提出的方案来看，就是最高位存储符号；无符号整数则相反，其存储不包含符号信息，也就是我们提出的第一个方案，是多少就存多少，只能表示\\(0\sim 2^{8}-1\\)。

如果按我们目前的方案，我们来考虑以下场景，寄存器A中存储了二进制数`10000010`，寄存器B中存储了二进制数`00000011`。按我们目前提到的方案来看，如果要计算加减，会变成这样：

* 如果A和B存储的是有符号数

   A存储十进制数-2，B存储十进制数3。A与B相加为1，二进制数为`00000001`；A与B相减为-5，二进制数为`10000101`。
* 如果A和B存储的是无符号数

   A存储十进制数130，B存储十进制数3。A与B相加为133，二进制数为`10000101`；A与B相减为127，二进制数为`01110000`。

我们的CPU如果需要同时支持有符号数和无符号数的加减法，看上去需要实现四个部件：有符号数加法器、有符号数减法器、无符号数加法器、无符号数减法器。

有没有更好的方法？

我们来看看天才般的先行者是怎么做的。

下面，我们用\\(\alpha=f(a)\\)表示将整数\\(a\\)记录到寄存器中，其中寄存器的值直接转化为无符号二进制数为\\(\alpha\\)。例如，按照我们之前的说法，`10011010`就表示负的二进制数`11010`，也就是-26，那么，\\(f(-26)=154\\)，因为`10011010`直接转化为无符号二进制数就是154。

那么，我们之前讲的对于无符号整数的记录方法就很直接：

$$
\alpha =f_u(a)=a
$$

我们该如何记录无符号整数呢？

首先，我们需要指出，由于寄存器的位数是有限的，因此对于一个\\(n\\)位寄存器来说，如果

$$
f(a)\equiv f(b)\pmod{2^{n}}
$$

那么\\(a\\)和\\(b\\)存储到寄存器中时，是没法看出差别的（因为它们在寄存器中的表现是相同的），也就是说，可以认为$a=b$。

我们天才般的先行者提出了**补码**的概念，对于有符号整数的记录：

$$
\alpha =f_s(a)=\begin{cases}
a&0\leq a\leq 2^{n-1}-1\\\\
2^{n}+a&-2^{n-1}\leq a<0
\end{cases}
$$

容易验证，对于两个寄存器中的值\\(\alpha=f_u(\alpha)=f_s(a)\\)和\\(\beta=f_u(\beta)=f_s(b)\\)，我们有：

$$
f_u^{-1}(f_u(\alpha) +f_u(\beta))=f_s^{-1}(f_s(a)+f_s(b))
$$

$$
f_u^{-1}(\alpha)+f_u^{-1}(\beta)\equiv f_s^{-1}(\alpha)+f_s^{-1}(\beta)\equiv f_u^{-1}(\alpha)-\beta \equiv f_s^{-1}(\alpha)-\beta\pmod{2^{n}}
$$

因此，

$$
f_u(f_u^{-1}(\alpha)+f_u^{-1}(\beta))=f_s(f_s^{-1}(\alpha)+f_s^{-1}(\beta))
$$

想要解决减法，一个想法自然出现了，既然\\(a-b=a+(-b)\\), 那可以在加法器中输入一个正数和一个负数来实现减法呀。

然而，我们知道，在计算机中，一个存储单位存储的数据大小是有上限的。比如说在64位CPU中，每个寄存器有64位，因此可以存储64位二进制数。因此，在CPU的加法器中，实际上使用了模\\(2^{64}\\)加法。也就是说，加法器做的，就是对于输入的两个64位二进制数\\(a\\)和\\(b\\), 输出64位二进制数\\((a+b)\bmod{2^{64}}\\). 

因此，我们只有找到合适的将负数记录成64位二进制数的方法，才能将加法器转化为减法器。

注意到

$$
a-b\equiv a+\left(2^{64}-b\right)\pmod{2^{64}}
$$

而由于\\(b\\)是64位二进制数，因此，\\(2^{64}-b\\)必然是一个正数，而正数的记录方法我们是知道的。因此，我们可以使用\\(2^{64}-b\\)来记录\\(-b\\), 其参与的减法就可以变成相应的加法。

但是，还有一个细节需要注意。比如说，我们想要记录的二进制数是`0xfffffffffffffffe`, 那么根据刚刚讨论的，我们可以将其记录为`0x1`. 这就出现了问题，如何区分`0x1`和`0xfffffffffffffffe`呢？我们采用这种方法只是为了方便减法，并不打算将正数和负数混同啊。

因此，在实际操作中，当出现负数时，能够允许的负数的绝对值最大值是\\(2^{63}\\). 换句话说，其记录值最高位`0`表示正数，`1`表示负数。这种记录方法叫做**补码**。也就是说，对于小于\\(2^{63}\\)的正数，采用其二进制表示为其实际记录；对于不低于\\(-2^{63}\\)的负数，将其加上\\(2^{64}\\)后的正数的二进制表示为其实际记录。如果采用补码，那么可以表示\\(-2^{63}\sim2^{63}-1\\)的整数。因此，采用补码记录的数称为**有符号整数**。反之，如果直接使用其二进制表示为其记录的话，那么只能表示\\(0\sim 2^{64}-1\\)的整数。因此，这种数的记录形式称为**无符号整数**。

提到有符号整数与无符号整数，有一句看似很有哲理的话：“存储在存储器中的数本没有有无符号的差别，只是若干高低电平。只有在操作它们的时候，它们才有了自己的符号。”理解这句话，对进一步深入编程底层很有帮助。举个例子，我们有一个8位的寄存器，其内容为二进制数`10001111`。这个寄存器内的数有符号吗？答案是它不含符号信息。它既可以是有符号整数`-0x71`，也可以是无符号整数`+0x8f`。只有在CPU对这个寄存器进行操作的时候，相应的值才会产生符号信息。例如，

## 逻辑运算

除了加减乘除以外，二进制数还有独特的运算——逻辑运算。分别是与(and), 或(or), 非(not)和异或(xor). 与或非大家都很熟悉了，异或就是当且仅当两个操作数不同时输出`1`, 相同时输出`0`.
