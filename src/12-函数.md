# 函数

在C语言等高级语言中，我们接触函数的概念一定非常多。在初步的印象里，我们往往会觉得函数与跳转并没有什么区别。是的，跳转本质上是将PC设置为目标指令的PC，从而实现控制流的跳转；而函数从表现上来看，也确实就是一个控制流的跳转。那么，函数是不是直接用跳转来做就可以了呢？或者说，与跳转相比，函数有什么独特之处，从而需要我们在汇编层面更加细致地来处理呢？

下面，我就列举一些函数与跳转的不同点。这些不同点，就决定了我们底层在处理函数的时候，需要额外更详细的处理方式。

* 函数在不同的地址被调用之后，返回的地址也不同。

   跳转之后的基本块结束之后去哪里，是固定的：

   ```armasm
   location_a:
       b    target
       ; ...
   location_b:
       b.eq target
       ; ...
   target:
       ; do something
       b    out
   out:
       ; ...
   ```

   无论我们是从`location_a`还是`location_b`跳转到`target`基本块，在`target`基本块执行结束后，继续去哪里是由`target`基本块本身决定的（在这里是去`out`基本块）。

   但是，我们在调用一个函数的时候，在函数执行结束之后，会前往上一层的下一条指令继续执行。这里函数结束之后去哪里，是根据我们调用函数的位置来决定的。
* 函数有参数、返回值
* 函数可以被别的文件里的程序调用

凡此种种，都表明函数是一种更特殊的跳转，其需要我们更细致地处理。

## ABI和调用约定

在正式介绍函数的细节之前，首先我们需要知道ABI，特别是调用约定。

ABI，全称是 _Application Binary Interface_，与API（_Application Program Interface_）对应。我们知道，一般来说，API是在同一个语言编写的程序中，一部分代码调用另一部分代码的方式。例如，我们在使用C语言编写程序的时候，想要实现打开一个文件的功能。而`stdio.h`库提供一个函数：

```c
FILE *fopen(const char *path, const char *mode);
```

我们只需要在我们自己C语言的程序中按照它给出的这个形式，也就是说，调用一个名字叫`fopen`的函数，给它传递两个参数，第一个是代表文件路径的字符串，第二个是代表打开时模式的字符串。在这个函数执行后，会返回一个`FILE *`类型的对象，后续对它进一步操作就行。

但这种API，都是在同一门语言中进行的。我们不需要了解任何二进制层面的东西，只需要在高级语言层面，按照API就能完成「对接」。

在二进制层面，对应API的就是ABI。在二进制层面，怎么调用别人写出来的二进制的代码呢？一般来说，如果通过二进制分发，那么上游的开发者会将程序编译成二进制的库。我们在编写自己程序的过程中，链接对方的库就可以调用对方的代码了。但是这些库中，也就单纯是指令、数据，以及一些符号信息。例如，我在使用Rust语言编写程序的时候，想调用别的开发者使用Go语言开发的库。那么，如果我想调用对方在Go语言中编写的`foo`函数，那么我在Rust语言中直接写`foo`这个名字吗？在Go语言中一个参数是`interface{}`类型，那我在Rust语言中该怎样传递这种参数呢？

这一些问题，仔细一想就会发现，一定会涉及底层的二进制层面。因为无论是什么函数名、是什么类型，最终都会落实到二进制层面的符号、数据、指令。这就是所谓的ABI。同时我们也可以发现，API层面，每个库都有自己的API；在ABI层面，每种语言都有自己的ABI。

一般来说，操作系统的库函数有统一的ABI。除了操作系统、C语言的ABI以外，其他语言的ABI往往都是不稳定的（也有很少的ABI稳定的语言，例如Swift（[ABI Stability and More](https://www.swift.org/blog/abi-stability-and-more/)））。

刚刚我们提到，ABI包含很多二进制层面的「对接」问题，而其中最重要的，就是函数之间的「对接」问题。解决这个问题的部分，被称为「调用约定」（Calling Convention）。ARM制定了自己的ABI标准，称为 _Procedure Call Standard_，可以在[ARM-software/abi-aa](https://github.com/ARM-software/abi-aa)中查看，常被简称为AAPCS for AArch64。而苹果针对这个标准，也进行了一定的增改，提供了自己的标准，可以在[Writing ARM64 Code for Apple Platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)中查看。

值得指出的是，调用约定与架构标准不同。AArch64架构标准规定，我们在执行`bl`指令后，PC一定会被置于目标函数的地址。而调用约定则**不是和硬件平台绑定的**。我们自己编写的汇编程序，在内部调用我们自己的函数，不一定遵守调用约定。只有在调用外部提供的函数的时候，才需要遵守相对应的调用约定。

在函数部分中，有大量的调用约定与架构标准。为了不引起混淆，我会在后面提到的时候专门指出，哪些是AArch64的调用约定，哪些是AArch64的架构标准。

## 函数的形式

首先，我们看看在汇编语言层面，一个函数长什么样：

```armasm
    .p2align 2
foo:
    ; do something
    ret
```

这就是一个最简单的函数的形式。也就是说，函数的名字和跳转一样，也就是个标签而已。我们在调用函数的时候，可以使用

```armasm
bl    foo
```

和直接跳转非常类似，也是直接跟着一个标签。底层逻辑就是将PC置于函数的首地址。

类似地，间接函数调用（也就是C语言中的函数指针）可以用：

```armasm
blr   x0
```

表示调用`x0`存储的地址对应的函数。

### 对齐

此外，我们应当注意到，在函数之前，我们会声明`.p2align 2`，也就是函数开头应按4字节对齐。这是AArch64的架构要求：

> A64 instructions must be word-aligned.
>
> Attempting to fetch an instruction from a misaligned location results in a PC alignment fault.

也就是说，每一个指令都应当4字节对齐。而由于A64的每一个指令都是定长指令，长度4字节，因此只需要函数开头按4字节对齐，就能保证这个函数内部每个指令都按4字节对齐。

### LR寄存器

那么，这种模式是怎么实现，在哪里调用就能返回到哪里的这个功能呢？

事实上，这里用到了一个特殊的通用寄存器：`r30`。相应的`x30`也被称作LR寄存器，即Link Register。当我们使用`bl`调用函数的时候，LR寄存器会被写入该函数的返回地址。因此，当我们在被调用函数内部使用`ret`指令时，实际上就是将PC设置为LR寄存器的值而已。

## 函数的栈

刚刚我们介绍了函数的相关指令，以及调用函数后，指令空间（也就是PC寄存器）是怎样变化的。接着，我们来看看数据空间是怎样变化的，也就是函数的栈。

### 栈的使用

我们在使用高级语言编程的过程中，函数内部往往会有许多局部变量。而这些局部变量往往都是存储在程序的栈区域里的。我们之前提到过，当操作系统将一个程序载入内存时，会给它分配相应的内存空间，往往会分为指令区、全局变量区、栈区、堆区。我们这里重点用到的就是栈区。

当操作系统将程序载入内存时，会直接分配一大块儿连续的**有效内存**作为栈区。也就是说，在栈区范围内的地址都是有效的。函数可以自由地将栈区内的内存作为自己的局部变量。但是，如果每个函数都随意地找栈空间内的地址作为自己的局部变量，我们没有办法保证这个函数不会用到那个函数已经用到的地址。因此，我们可以遵循一种线性的栈空间的使用方式，同时也就用到了寄存器`sp`。

从每个函数的角度来看，在函数开始的时候，所有函数都会默认，`sp`存储的地址，往上是别的函数已经用过的地址，往下是自己可以用的地址。在调用下一个函数之前，会更新自己的`sp`，将`sp`减小，也就是留出自己的栈空间，防止子函数覆盖自己的栈空间。在函数返回之前，会将`sp`恢复成刚进入函数的模样。

从整体来看，当操作系统分配完栈空间后，会将特殊寄存器`sp`的值置为这个栈空间的顶端的地址（也就是最大的地址）。在函数层层调用的过程中，`sp`的减少代表进入了新的函数，给函数的局部变量留下了空间；`sp`的增加代表函数返回，恢复到上一层的`sp`。

下面，我们就具体来看看在汇编层面的`sp`有什么用。首先，我们来看看示例程序：

```c
void foo() {
    int a;
    char b;
    long c;
    a = 1;
    bar();
}
```

### 栈空间分配

在`foo`内，有一个4字节的局部变量`a`，1字节的局部变量`b`，8字节的局部变量`c`。

第一个问题：在调用`bar`之前，我们要预留多大的栈空间？也就是说，要将`sp`减少多少？

要解决这个问题，我们需要知道几个规则：

* 栈按16字节对齐

   AArch64架构规范从硬件上要求在每一个函数开始的时候，`sp`的值必须是16的倍数。因此，我们将`sp`减小的值，也必须是16的倍数。
* 数据对齐访问性能最好

   这一点之前已经讲过。也就是说，4字节的`a`按4字节对齐，1字节的`b`按1字节对齐，8字节的`c`按8字节对齐，这样性能最好。
* 栈中有16字节的预留位置

   除了局部变量以外，还有16个字节的位置是预留的，分别是存储进入函数时LR寄存器的值和FP寄存器的值。

   FP寄存器之后会提到。这里先解释一下为什么需要存储LR寄存器的值。我们刚刚提到，在使用`bl`指令调用函数的时候，LR寄存器会被赋值为函数的返回地址，`ret`指令也是依靠LR寄存器的值才知道返回到哪里。那么，如果我们在函数内部再一次调用函数时，LR寄存器的值会被覆盖。因此，如果我们不把LR寄存器的值存下来，在返回之前写回去，那函数就返回不了了。所以，我们通用的做法就是，在函数开头，将LR存储到栈上；在函数返回之前，再将栈上的数据写回到函数里。

可以想见，我们可以这样布局函数的栈空间：

```plaintext
 ----------------------       <---------    Previous sp, 16 byte aligned
|  LR register value   |      <---------    8 bytes LR register value
 ----------------------
| old FP register value|      <---------    8 bytes old FP register value
 ----------------------       <---------    Current FP
|        int a         |      <---------    4 bytes variable a
 ----------------------       <---------    Address of a, 4 byte aligned
|        char b        |      <---------    1 byte variable b
 ----------------------       <---------    Address of b, 1 byte aligned
|       Padding        |      <---------    3 bytes padding
 ----------------------
|        long c        |      <---------    8 bytes variable c
 ----------------------       <---------    Address of c, 8 byte aligned. Current sp, 16 byte aligned
```

也就是说，栈空间为32字节，我们在函数开头的时候可以将`sp`减小32。从而`a`的地址为`sp + 12`，`b`的地址为`sp + 11`，`c`的地址为`sp`。

值得指出，LR和FP组成的预留位置，在AArch64的ABI中并没有明确规定其在函数栈空间的位置。在Apple Silicon中，它位于栈的底部（也就是高地址区域）。

和通用寄存器一样，我们的特殊寄存器`sp`也可以参与`add`、`sub`之中。在函数开始的时候，我们可以减小`sp`：

```armasm
foo:
    sub    sp, sp, #32
```

在函数返回之前，再把`sp`复原：

```armasm
add    sp, sp, #32
ret
```

访问栈上的局部变量的时候，可以使用在[内存交互](./10-内存交互.md)一章中介绍的「基寄存器+常数偏移」的寻址模式。`a = 1`可以翻译为

```armasm
mov    w8, #1
str    w8, [sp, #12]
```

### 帧指针FP寄存器

刚刚我们提到，AArch64调用约定规定，在函数栈上，除了LR寄存器之外，我们还需要存储FP寄存器。FP寄存器，实际上就是`r29`寄存器。FP寄存器是做什么用的呢？我们先不说，下面来介绍一下FP寄存器在函数调用的过程中是怎么用的。通过用法，我们就可以知道FP寄存器是做什么的了。

* 在函数开始的时候，同LR寄存器一样，我们需要把当前的FP寄存器的值存在栈上。随后，将当前栈顶指针`sp`的值赋给FP。也就是说，此时FP寄存器的值，指向的就是之前FP寄存器值存储在栈上的地址。
* 在函数返回的时候，将栈上FP的值再写回FP寄存器。

通过这种做法，FP可以帮助我们做以下的工作：

#### 访问栈上变量

首先，FP可以帮我们访问栈上变量。我们之前提过，可以通过`sp`+偏移的方式访问局部变量。但是我们知道，在函数内部，`sp`的值有可能不断变化。那么，计算出相应的偏移也是给编译器增加负担。而FP指向的值是固定的，我们从而可以通过FP为基寄存器，访问局部变量。

例如，在上面的例子中，我们可以通过`sp + 12`获得`a`的地址。同理，我们也可以通过`fp - 4`获得`a`的地址：

```armasm
mov    w8, #1
str    w8, [x29, #-4]
```

#### 回溯函数调用栈

当我们分析程序，或者其他特殊情况的过程中，可以根据FP来回溯函数调用栈。这是什么意思呢？我们可以用一个C语言的结构体来解释，通过FP，函数的栈帧可以粗略地理解成这样一个结构体：

```c
struct StackFrame {
    unsigned long ret_addr;
    struct StackFrame *previous_stack_frame;
    char remain[];
};
```

存储在栈上的FP的值可以看作指向前一个函数栈帧的指针，从而函数的栈帧成了一个链表。我们可以通过这个链表，回溯函数的调用栈。

### Prologue与Epilogue

根据我们上面的叙述，在函数调用的过程中，总会涉及到将LR、FP寄存器存到栈上等等操作。这些操作是固定的，在函数开头执行的操作被称为Prologue，在函数返回前执行的操作被称为Epilogue。

#### LR、FP寄存器与栈交互

在Prologue中，我们需要将LR、FP寄存器存入栈上；在Epilogue中，我们需要将栈上数据读入LR和FP中。

这种成对的数据内存读写，AArch64为我们提供了`stp`和`ldp`指令：

```armasm
stp    x29, x30, [sp]
```

表示将`x29`存储到`sp`，`x30`存储到`sp + 8`；

```armasm
ldp    x29, x30, [sp]
```

表示将`sp`读取8字节至`x29`，`sp + 8`读取8字节至`x30`。

#### 完整代码

了解了`stp`和`ldp`之后，我们就可以知道函数Prologue与Epilogue的完整代码了。以上面的C语言程序`void foo`为例。

##### Prologue

```armasm
_foo:
    sub    sp, sp, #32
    stp    x29, x30, [sp, #16]
    add    x29, sp, #16
```

##### Epilogue

```armasm
ldp    x29, x30, [sp, #16]
add    sp, sp, #32
ret
```

### Red zone



### 栈溢出攻击

在刚刚阐述LR寄存器的时候，我们可以发现一点：

* 在函数开头，把LR存栈上
* 在函数返回前，从栈上读数据，存储到LR中
* 函数返回时，根据LR的值，决定执行哪条指令

那我们如果在函数执行的过程中，修改栈上的数据，是不是就可以控制程序的控制流了！事实上，确实是这样的。我们来看一个最简单的程序（可以在本GitHub仓库的`codes/`目录下找到`12-stack-overflow.c`文件）：

```c
int main() {
    char buf[16];
    scanf("%s", buf);
    return 0;
}
```

在`scanf`的过程中，并没有对输入的长度进行判断。那么我们如果不停地输入`a`，会发生什么情况呢？

![stack overflow](./assets/12-stackoverflow.png)

程序崩溃了！仔细想想也是理所当然的，`buf`的地址在LR在栈上的地址之下，我们不断向`buf`中填充数值，肯定会覆盖到LR在栈上的位置。从而在函数返回时，`ret`返回的地址就变成了我们输入的值，如果是无效地址，就崩溃了。

真正的攻击则是会在执行时算好地址，从而能够劫持控制流。之前介绍的ASLR、PIC等方案，就是通过随机化地址的方式，让攻击者难以算出真正的地址，从而只能导致程序崩溃，而不是让程序执行自己想要的指令。
