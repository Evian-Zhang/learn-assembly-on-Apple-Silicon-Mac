# 函数

在C语言等高级语言中，我们接触函数的概念一定非常多。在初步的印象里，我们往往会觉得函数与跳转并没有什么区别。是的，跳转本质上是将PC设置为目标指令的PC，从而实现控制流的跳转；而函数从表现上来看，也确实就是一个控制流的跳转。那么，函数是不是直接用跳转来做就可以了呢？或者说，与跳转相比，函数有什么独特之处，从而需要我们在汇编层面更加细致地来处理呢？

下面，我就列举一些函数与跳转的不同点。这些不同点，就决定了我们底层在处理函数的时候，需要额外更详细的处理方式。

* 函数在不同的地址被调用之后，返回的地址也不同。

   跳转之后的基本块结束之后去哪里，是固定的：

   ```armasm
   location_a:
       b    target
       ; ...
   location_b:
       b.eq target
       ; ...
   target:
       ; do something
       b    out
   out:
       ; ...
   ```

   无论我们是从`location_a`还是`location_b`跳转到`target`基本块，在`target`基本块执行结束后，继续去哪里是由`target`基本块本身决定的（在这里是去`out`基本块）。

   但是，我们在调用一个函数的时候，在函数执行结束之后，会前往上一层的下一条指令继续执行。这里函数结束之后去哪里，是根据我们调用函数的位置来决定的。
* 函数有参数、返回值
* 函数可以被别的文件里的程序调用

凡此种种，都表明函数是一种更特殊的跳转，其需要我们更细致地处理。

## 函数的形式

首先，我们看看在汇编语言层面，一个函数长什么样：

```armasm
    .p2align 2
foo:
    ; do something
    ret
```

这就是一个最简单的函数的形式。也就是说，函数的名字和跳转一样，也就是个标签而已。我们在调用函数的时候，可以使用

```armasm
bl    foo
```

和直接跳转非常类似，也是直接跟着一个标签。类似地，间接函数调用（也就是C语言中的函数指针）可以用：

```armasm
blr   x0
```

表示调用`x0`存储的地址对应的函数。

## ABI和调用约定

在正式介绍函数的细节之前，首先我们需要知道ABI，特别是调用约定。

ABI，全称是 _Application Binary Interface_，与API（_Application Program Interface_）对应。我们知道，一般来说，API是在同一个语言编写的程序中，一部分代码调用另一部分代码的方式。例如，我们在使用C语言编写程序的时候，想要实现打开一个文件的功能。而`stdio.h`库提供一个函数：

```c
FILE *fopen(const char *path, const char *mode);
```

我们只需要在我们自己C语言的程序中按照它给出的这个形式，也就是说，调用一个名字叫`fopen`的函数，给它传递两个参数，第一个是代表文件路径的字符串，第二个是代表打开时模式的字符串。在这个函数执行后，会返回一个`FILE *`类型的对象，后续对它进一步操作就行。

但这种API，都是在同一门语言中进行的。我们不需要了解任何二进制层面的东西，只需要在高级语言层面，按照API就能完成「对接」。

在二进制层面，对应API的就是ABI。在二进制层面，怎么调用别人写出来的二进制的代码呢？一般来说，如果通过二进制分发，那么上游的开发者会将程序编译成二进制的库。我们在编写自己程序的过程中，链接对方的库就可以调用对方的代码了。但是这些库中，也就单纯是指令、数据，以及一些符号信息。例如，我在使用Rust语言编写程序的时候，想调用别的开发者使用Go语言开发的库。那么，如果我想调用对方在Go语言中编写的`foo`函数，那么我在Rust语言中直接写`foo`这个名字吗？在Go语言中一个参数是`interface{}`类型，那我在Rust语言中该怎样传递这种参数呢？

这一些问题，仔细一想就会发现，一定会涉及底层的二进制层面。因为无论是什么函数名、是什么类型，最终都会落实到二进制层面的符号、数据、指令。这就是所谓的ABI。同时我们也可以发现，API层面，每个库都有自己的API；在ABI层面，每种语言都有自己的ABI。

一般来说，操作系统的库函数有统一的ABI。除了操作系统、C语言的ABI以外，其他语言的ABI往往都是不稳定的（也有很少的ABI稳定的语言，例如Swift（[ABI Stability and More](https://www.swift.org/blog/abi-stability-and-more/)））。

刚刚我们提到，ABI包含很多二进制层面的「对接」问题，而其中最重要的，就是函数之间的「对接」问题。解决这个问题的部分，被称为「调用约定」（Calling Convention）。ARM制定了自己的ABI标准，称为 _Procedure Call Standard_，可以在[ARM-software/abi-aa](https://github.com/ARM-software/abi-aa)中查看。而苹果针对这个标准，也进行了一定的增改，提供了自己的标准，可以在[Writing ARM64 Code for Apple Platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)中查看。

值得指出的是，调用约定与指令语义不同。我们在执行`bl`指令后，PC一定会被置于目标函数的地址。而调用约定则**不是和硬件绑定的**。我们自己编写的汇编程序，在内部调用我们自己的函数，不一定遵守调用约定。只有在调用外部提供的函数的时候，才需要遵守相对应的调用约定。

在函数部分中，有大量的调用约定与指令语义。为了不引起混淆，我会在后面提到的时候专门指出，哪些是调用约定，哪些是指令语义。
