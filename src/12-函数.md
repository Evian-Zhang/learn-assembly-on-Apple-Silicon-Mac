# 函数

在C语言等高级语言中，我们接触函数的概念一定非常多。在初步的印象里，我们往往会觉得函数与跳转并没有什么区别。是的，跳转本质上是将PC设置为目标指令的PC，从而实现控制流的跳转；而函数从表现上来看，也确实就是一个控制流的跳转。那么，函数是不是直接用跳转来做就可以了呢？或者说，与跳转相比，函数有什么独特之处，从而需要我们在汇编层面更加细致地来处理呢？

下面，我就列举一些函数与跳转的不同点。这些不同点，就决定了我们底层在处理函数的时候，需要额外更详细的处理方式。

* 函数在不同的地址被调用之后，返回的地址也不同。

   跳转之后的基本块结束之后去哪里，是固定的：

   ```armasm
   location_a:
       b    target
       ; ...
   location_b:
       b.eq target
       ; ...
   target:
       ; do something
       b    out
   out:
       ; ...
   ```

   无论我们是从`location_a`还是`location_b`跳转到`target`基本块，在`target`基本块执行结束后，继续去哪里是由`target`基本块本身决定的（在这里是去`out`基本块）。

   但是，我们在调用一个函数的时候，在函数执行结束之后，会前往上一层的下一条指令继续执行。这里函数结束之后去哪里，是根据我们调用函数的位置来决定的。
* 函数有参数、返回值
* 函数可以被别的文件里的程序调用

凡此种种，都表明函数是一种更特殊的跳转，其需要我们更细致地处理。

## ABI和调用约定

在正式介绍函数的细节之前，首先我们需要知道ABI，特别是调用约定。

ABI，全称是 _Application Binary Interface_，与API（_Application Program Interface_）对应。我们知道，一般来说，API是在同一个语言编写的程序中，一部分代码调用另一部分代码的方式。例如，我们在使用C语言编写程序的时候，想要实现打开一个文件的功能。而`stdio.h`库提供一个函数：

```c
FILE *fopen(const char *path, const char *mode);
```

我们只需要在我们自己C语言的程序中按照它给出的这个形式，也就是说，调用一个名字叫`fopen`的函数，给它传递两个参数，第一个是代表文件路径的字符串，第二个是代表打开时模式的字符串。在这个函数执行后，会返回一个`FILE *`类型的对象，后续对它进一步操作就行。

但这种API，都是在同一门语言中进行的。我们不需要了解任何二进制层面的东西，只需要在高级语言层面，按照API就能完成「对接」。

在二进制层面，对应API的就是ABI。在二进制层面，怎么调用别人写出来的二进制的代码呢？一般来说，如果通过二进制分发，那么上游的开发者会将程序编译成二进制的库。我们在编写自己程序的过程中，链接对方的库就可以调用对方的代码了。但是这些库中，也就单纯是指令、数据，以及一些符号信息。例如，我在使用Rust语言编写程序的时候，想调用别的开发者使用Go语言开发的库。那么，如果我想调用对方在Go语言中编写的`foo`函数，那么我在Rust语言中直接写`foo`这个名字吗？在Go语言中一个参数是`interface{}`类型，那我在Rust语言中该怎样传递这种参数呢？

这一些问题，仔细一想就会发现，一定会涉及底层的二进制层面。因为无论是什么函数名、是什么类型，最终都会落实到二进制层面的符号、数据、指令。这就是所谓的ABI。同时我们也可以发现，API层面，每个库都有自己的API；在ABI层面，每种语言都有自己的ABI。

一般来说，操作系统的库函数有统一的ABI。除了操作系统、C语言的ABI以外，其他语言的ABI往往都是不稳定的（也有很少的ABI稳定的语言，例如Swift（[ABI Stability and More](https://www.swift.org/blog/abi-stability-and-more/)））。

刚刚我们提到，ABI包含很多二进制层面的「对接」问题，而其中最重要的，就是函数之间的「对接」问题。解决这个问题的部分，被称为「调用约定」（Calling Convention）。ARM制定了自己的ABI标准，称为 _Procedure Call Standard_，可以在[ARM-software/abi-aa](https://github.com/ARM-software/abi-aa)中查看，常被简称为AAPCS for AArch64。而苹果针对这个标准，也进行了一定的增改，提供了自己的标准，可以在[Writing ARM64 Code for Apple Platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)中查看。

值得指出的是，调用约定与架构标准不同。AArch64架构标准规定，我们在执行`bl`指令后，PC一定会被置于目标函数的地址。而调用约定则**不是和硬件平台绑定的**。我们自己编写的汇编程序，在内部调用我们自己的函数，不一定遵守调用约定。只有在调用外部提供的函数的时候，才需要遵守相对应的调用约定。

在函数部分中，有大量的调用约定与架构标准。为了不引起混淆，我会在后面提到的时候专门指出，哪些是AArch64的调用约定，哪些是AArch64的架构标准。

## 函数的形式

首先，我们看看在汇编语言层面，一个函数长什么样：

```armasm
    .p2align 2
foo:
    ; do something
    ret
```

这就是一个最简单的函数的形式。也就是说，函数的名字和跳转一样，也就是个标签而已。我们在调用函数的时候，可以使用

```armasm
bl    foo
```

和直接跳转非常类似，也是直接跟着一个标签。底层逻辑就是将PC置于函数的首地址。

类似地，间接函数调用（也就是C语言中的函数指针）可以用：

```armasm
blr   x0
```

表示调用`x0`存储的地址对应的函数。

此外，我们应当注意到，在函数之前，我们会声明`.p2align 2`，也就是函数开头应按4字节对齐。这是AArch64的架构要求：

> A64 instructions must be word-aligned.
>
> Attempting to fetch an instruction from a misaligned location results in a PC alignment fault.

也就是说，每一个指令都应当4字节对齐。而由于A64的每一个指令都是定长指令，长度4字节，因此只需要函数开头按4字节对齐，就能保证这个函数内部每个指令都按4字节对齐。

## 函数的栈

刚刚我们介绍了函数的相关指令，以及调用函数后，指令空间（也就是PC寄存器）是怎样变化的。接着，我们来看看数据空间是怎样变化的，也就是函数的栈。

### 栈的使用

我们在使用高级语言编程的过程中，函数内部往往会有许多局部变量。而这些局部变量往往都是存储在程序的栈区域里的。我们之前提到过，当操作系统将一个程序载入内存时，会给它分配相应的内存空间，往往会分为指令区、全局变量区、栈区、堆区。我们这里重点用到的就是栈区。

当操作系统将程序载入内存时，会直接分配一大块儿连续的**有效内存**作为栈区。也就是说，在栈区范围内的地址都是有效的。函数可以自由地将栈区内的内存作为自己的局部变量。但是，如果每个函数都随意地找栈空间内的地址作为自己的局部变量，我们没有办法保证这个函数不会用到那个函数已经用到的地址。因此，我们可以遵循一种线性的栈空间的使用方式，同时也就用到了寄存器`sp`。

从每个函数的角度来看，在函数开始的时候，所有函数都会默认，`sp`存储的地址，往上是别的函数已经用过的地址，往下是自己可以用的地址。在调用下一个函数之前，会更新自己的`sp`，将`sp`减小，也就是留出自己的栈空间，防止子函数覆盖自己的栈空间。在函数返回之前，会将`sp`恢复成刚进入函数的模样。

从整体来看，当操作系统分配完栈空间后，会将特殊寄存器`sp`的值置为这个栈空间的顶端的地址（也就是最大的地址）。在函数层层调用的过程中，`sp`的减少代表进入了新的函数，给函数的局部变量留下了空间；`sp`的增加代表函数返回，恢复到上一层的`sp`。

下面，我们就具体来看看在汇编层面的`sp`有什么用。首先，我们来看看示例程序：

```c
void foo() {
    int a;
    char b;
    long c;
    a = 1;
    bar();
}
```

### 栈空间分配

在`foo`内，有一个4字节的局部变量`a`，1字节的局部变量`b`，8字节的局部变量`c`。

第一个问题：在调用`bar`之前，我们要预留多大的栈空间？也就是说，要将`sp`减少多少？

要解决这个问题，我们需要知道几个规则：

* 栈按16字节对齐

   AArch64架构规范从硬件上要求在每一个函数开始的时候，`sp`的值必须是16的倍数。因此，我们将`sp`减小的值，也必须是16的倍数。
* 数据对齐访问性能最好

   这一点之前已经讲过。也就是说，4字节的`a`按4字节对齐，1字节的`b`按1字节对齐，8字节的`c`按8字节对齐，这样性能最好。
* 栈中有16字节的预留位置

   除了局部变量以外，还有16个字节的位置是预留的。这个我们之后会解释，这里暂时先不管是什么。

可以想见，我们的栈布局是这样的最合理：

```plaintext
 -------------------       <---------    Previous sp, 16 byte aligned
|     reserved      |      <---------    16 bytes reserved area
 -------------------
|       int a       |      <---------    4 bytes variable a
 -------------------       <---------    Address of a, 4 byte aligned
|      char b       |      <---------    1 byte variable b
 -------------------       <---------    Address of b, 1 byte aligned
|      Padding      |      <---------    3 bytes padding
 -------------------
|      long c       |      <---------    8 bytes variable c
 -------------------       <---------    Address of c, 8 byte aligned. Current sp, 16 byte aligned
```

也就是说，栈空间为32字节，我们在函数开头的时候可以将`sp`减小32。从而`a`的地址为`sp + 12`，`b`的地址为`sp + 11`，`c`的地址为`sp`。

和通用寄存器一样，我们的特殊寄存器`sp`也可以参与`add`、`sub`之中。在函数开始的时候，我们可以减小`sp`：

```armasm
foo:
    sub    sp, sp, #32
```

在函数返回之前，再把`sp`复原：

```armasm
add    sp, sp, #32
ret
```

访问栈上的局部变量的时候，可以使用在[内存交互](./10-内存交互.md)一章中介绍的「基寄存器+常数偏移」的寻址模式。`a = 1`可以翻译为

```armasm
mov    x8, #1
str    x8, [sp, #12]
```


