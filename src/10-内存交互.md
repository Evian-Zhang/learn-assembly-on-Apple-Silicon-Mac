# 内存交互

目前我们所叙述的赋值指令、数据处理指令，都是在寄存器层面进行的。那么，如何与内存进行交互呢？

## C语言层面的内存

首先我们需要知道，为什么要与内存交互。在[硬件基础](./3-硬件基础.md)中我们提到，理论上，如果我们有能力CPU直连几十上百万个寄存器，那么是不需要内存的。从另一个层面来讲，如果我们能做到内存与CPU之间的读取速度和寄存器类似，那么我们也不需要寄存器了。也就是说，内存以量取胜，寄存器以速度取胜。我们在编程中的变量动辄成千上百个，都存储在寄存器中也就因此不现实。

因此，我们在C语言中使用的**变量**，默认情况下往往都是存储在内存中的。但是，当我们涉及到具体的数据处理等等指令的时候，其必须操作寄存器。所以，我们在操作变量的过程中，底层实际上首先都是需要将变量对应的内存中的值传入寄存器的。因此，这里就涉及到与内存进行交互。

这里再顺便提一句，C语言中并非所有变量都会放在内存中。编译器可以根据不同的情况进行优化，可以将变量优化到寄存器中。对于某些编译器来说，我们也可以通过`register`关键词提示编译器，我们希望这个变量存储在寄存器中而不是内存中。

## 内存交互指令

基本的内存交互指令就是`ldr`和`str`了。这两条指令的用法为：

```plaintext
ldr{sign}{size}    dest_reg, [mem_addr]
str{size}          dest_reg, [mem_addr]
```

我们首先先不讲`[mem_addr]`的细节，来看几个实例：

```plaintext
strb    w0, [mem_addr]    ; Instruction 1
ldrh    x1, [mem_addr]    ; Instruction 2
ldrsb   w2, [mem_addr]    ; Instruction 3
```

这三条指令的意思分别是：

* 指令1

   将`r0`寄存器最低位的1个字节的内容，存储到地址为`mem_addr`的内存中。
* 指令2

   将`mem_addr`处开始的2个字节的内存内容，无符号扩展地存储到`r1`寄存器的低2字节位置
* 指令3

   将`mem_addr`处开始的1个字节的内存内容，有符号扩展地存储到`r2`寄存器的最低的1个字节中

首先，粗粒度地来看，`ldr`就是将内存数据读取到寄存器中，`str`就是将寄存器数据存储到内存中。

### 操作长度

但是由于寄存器的长度和内存单元长度不一致，导致了问题的复杂化。我们知道，AArch64架构下的通用寄存器长度都是64位，也就是8个字节。我们在汇编语言中能操作的寄存器，也就是`x0`、`w0`等，也就只有8字节和4字节两种。但是，内存的最小单位是1个字节。因此，在寄存器与内存交互的过程中，需要有一种方法以1字节为粒度来控制。

所以，`ldr`和`str`指令后面才需要跟着`{size}`。这里的`{size}`，`b`表示1字节，`h`表示2字节，`w`表示4字节。例如，`strb`表示存储1字节的内容，`ldrw`表示读取4字节的内容。当我们想表示的字节与目的操作数的宽度一致时，可以省略。例如，如果想将`w0`的全部4字节内容存储到内存中，那么我们既可以写`strw    w0, [mem_addr]`，也可以省略`w`，直接写`str    w0, [mem_addr]`。

### 扩展

通过`{size}`后缀的这种方法，可以有效地解决寄存器宽度与内存操作单元长度不一致的问题，以1字节的粒度进行寄存器与内存之间的交互。这在存储过程中没有问题，但是在读取内存的过程中，还剩下一个问题。如果我想从内存中读取1个字节的内容，存储到`r0`寄存器中，那`r0`寄存器中剩下的7个字节该怎么办？

这个问题的解决方法在[赋值指令](./8-赋值指令.md)一章中介绍了，就是无符号扩展与有符号扩展。当我们使用`ldrsb`时，会将内存中这1个字节的内容，有符号扩展地存储到寄存器中；直接使用`ldrb`，则是无符号扩展。

### 端序

此外还有一个小问题，就是端序。例如，我们目前`w0`的值为`0x12345678`，如果存储到`0x400000`地址的内存单元中，那么内存单元的内容该怎样分布呢？

* 小端序

   寄存器中的低位会存储在内存的低地址中：

   `0x400000`处为`0x78`, `0x400001`处为`0x56`，`0x400002`处为`0x34`，`0x400003`处为`0x12`。
* 大端序

   寄存器中的低位会存储在内存的高地址中：

   `0x400000`处为`0x12`, `0x400001`处为`0x34`，`0x400002`处为`0x56`，`0x400003`处为`0x78`。

在[硬件基础](./3-硬件基础.md)一章中我们提到，Apple Silicon使用的是小端序。

### 数据对齐（Alignment）

在绝大多数指令集架构中，都会有数据对齐的要求。意思是说，我们读取/写入内存时，对内存地址本身也是有要求的。一般来说，对齐的字节数与读取/写入的字节数相同。例如，我们使用`ldrw`从内存中读取4字节的内容，那么根据要求，我们读取的地址本身，需要是4的倍数。

这种对齐要求在目前的Apple Silicon中并不是强制的。但是，读取/写入对齐的地址，可以防止意外的性能损失。

事实上，在某些架构中，不对齐的内存访问会直接产生异常，甚至不产生异常而是出现错误的结果。这也是现代的安全的编程语言，例如Rust，有[`ptr::read`](https://doc.rust-lang.org/std/ptr/fn.read.html)和[`ptr::read_unaligned`](https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html)两种函数的原因。

这种对齐对我们的日常编程有什么影响呢？这里简单举一个例子：

在本GitHub仓库的`codes/`目录下的`10-alignment.c`文件中，我们有一个C语言的结构体：

```c
struct AlignedStruct {
    short a;
    char b;
    int c;
};
```

使用Clang编译后这个文件，运行它，得到输出：

```plaintext
sizeof(short) is 2, sizeof(char) is 1, sizeof(int) is 4, but sizeof(struct AlignedStruct) is 8
Inside struct AlignedStruct, short a is at pos 0, char b is at pos 2, int c is at pos 4
```

可以发现，这个结构体并不是简单地将一个2字节的`a`、一个1字节的`b`和一个4字节的`c`合并在一起变成7字节的结构体，而是在`b`字段后补了一个1字节的padding。

从某种意义上来说，这也是因为数据对齐。试想，如果我们想不产生性能损耗，那么，`a`的地址应该以2字节对齐，`b`的地址应该以1字节对齐，`c`的地址应该以4字节对齐。那么，使用一个非常简单的想法，就是`b`后补1个字节，这样就能同时保证这三点了。

这从某种意义上说，也是各种网络报文，例如IP报文头（如下图，改编自[IETF的RFC791](https://datatracker.ietf.org/doc/html/rfc791)）如此规整的原因。

```plaintext
 0               1               2               3
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
