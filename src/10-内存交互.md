# 内存交互

目前我们所叙述的赋值指令、数据处理指令，都是在寄存器层面进行的。那么，如何与内存进行交互呢？

## C语言层面的内存

首先我们需要知道，为什么要与内存交互。在[硬件基础](./3-硬件基础.md)中我们提到，理论上，如果我们有能力CPU直连几十上百万个寄存器，那么是不需要内存的。从另一个层面来讲，如果我们能做到内存与CPU之间的读取速度和寄存器类似，那么我们也不需要寄存器了。也就是说，内存以量取胜，寄存器以速度取胜。我们在编程中的变量动辄成千上百个，都存储在寄存器中也就因此不现实。

因此，我们在C语言中使用的**变量**，默认情况下往往都是存储在内存中的。但是，当我们涉及到具体的数据处理等等指令的时候，其必须操作寄存器。所以，我们在操作变量的过程中，底层实际上首先都是需要将变量对应的内存中的值传入寄存器的。因此，这里就涉及到与内存进行交互。

这里再顺便提一句，C语言中并非所有变量都会放在内存中。编译器可以根据不同的情况进行优化，可以将变量优化到寄存器中。对于某些编译器来说，我们也可以通过`register`关键词提示编译器，我们希望这个变量存储在寄存器中而不是内存中。

## 内存交互指令

基本的内存交互指令就是`ldr`和`str`了。这两条指令的用法为：

```plaintext
ldr{sign}{size}    dest_reg, [mem_addr]
str{size}          dest_reg, [mem_addr]
```

我们首先先不讲`[mem_addr]`的细节，来看几个实例：

```plaintext
strb    w0, [mem_addr]    ; Instruction 1
ldrh    x1, [mem_addr]    ; Instruction 2
ldrsb   w2, [mem_addr]    ; Instruction 3
```

这三条指令的意思分别是：

* 指令1

   将`r0`寄存器最低位的1个字节的内容，存储到地址为`mem_addr`的内存中。
* 指令2

   将`mem_addr`处开始的2个字节的内存内容，无符号扩展地存储到`r1`寄存器的低2字节位置
* 指令3

   将`mem_addr`处开始的1个字节的内存内容，有符号扩展地存储到`r2`寄存器的最低的1个字节中

首先，粗粒度地来看，`ldr`就是将内存数据读取到寄存器中，`str`就是将寄存器数据存储到内存中。

### 操作长度

但是由于寄存器的长度和内存单元长度不一致，导致了问题的复杂化。我们知道，AArch64架构下的通用寄存器长度都是64位，也就是8个字节。我们在汇编语言中能操作的寄存器，也就是`x0`、`w0`等，也就只有8字节和4字节两种。但是，内存的最小单位是1个字节。因此，在寄存器与内存交互的过程中，需要有一种方法以1字节为粒度来控制。

所以，`ldr`和`str`指令后面才需要跟着`{size}`。这里的`{size}`，`b`表示1字节，`h`表示2字节，`w`表示4字节。例如，`strb`表示存储1字节的内容，`ldrw`表示读取4字节的内容。当我们想表示的字节与目的操作数的宽度一致时，可以省略。例如，如果想将`w0`的全部4字节内容存储到内存中，那么我们既可以写`strw    w0, [mem_addr]`，也可以省略`w`，直接写`str    w0, [mem_addr]`。

### 扩展

通过`{size}`后缀的这种方法，可以有效地解决寄存器宽度与内存操作单元长度不一致的问题，以1字节的粒度进行寄存器与内存之间的交互。这在存储过程中没有问题，但是在读取内存的过程中，还剩下一个问题。如果我想从内存中读取1个字节的内容，存储到`r0`寄存器中，那`r0`寄存器中剩下的7个字节该怎么办？

这个问题的解决方法在[赋值指令](./8-赋值指令.md)一章中介绍了，就是无符号扩展与有符号扩展。当我们使用`ldrsb`时，会将内存中这1个字节的内容，有符号扩展地存储到寄存器中；直接使用`ldrb`，则是无符号扩展。

### 端序

此外还有一个小问题，就是端序。例如，我们目前`w0`的值为`0x12345678`，如果存储到`0x400000`地址的内存单元中，那么内存单元的内容该怎样分布呢？

* 小端序

   寄存器中的低位会存储在内存的低地址中：

   `0x400000`处为`0x78`, `0x400001`处为`0x56`，`0x400002`处为`0x34`，`0x400003`处为`0x12`。
* 大端序

   寄存器中的低位会存储在内存的高地址中：

   `0x400000`处为`0x12`, `0x400001`处为`0x34`，`0x400002`处为`0x56`，`0x400003`处为`0x78`。

在[硬件基础](./3-硬件基础.md)一章中我们提到，Apple Silicon使用的是小端序。

### 数据对齐（Alignment）

在绝大多数指令集架构中，都会有数据对齐的要求。意思是说，我们读取/写入内存时，对内存地址本身也是有要求的。一般来说，对齐的字节数与读取/写入的字节数相同。例如，我们使用`ldrw`从内存中读取4字节的内容，那么根据要求，我们读取的地址本身，需要是4的倍数。

这种对齐要求在目前的Apple Silicon中并不是强制的。但是，读取/写入对齐的地址，可以防止意外的性能损失。

事实上，在某些架构中，不对齐的内存访问会直接产生异常，甚至不产生异常而是出现错误的结果。这也是现代的安全的编程语言，例如Rust，有[`ptr::read`](https://doc.rust-lang.org/std/ptr/fn.read.html)和[`ptr::read_unaligned`](https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html)两种函数的原因。

这种对齐对我们的日常编程有什么影响呢？这里简单举一个例子：

在本GitHub仓库的`codes/`目录下的`10-alignment.c`文件中，我们有一个C语言的结构体：

```c
struct AlignedStruct {
    short a;
    char b;
    int c;
};
```

使用Clang编译后这个文件，运行它，得到输出：

```plaintext
sizeof(short) is 2, sizeof(char) is 1, sizeof(int) is 4, but sizeof(struct AlignedStruct) is 8
Inside struct AlignedStruct, short a is at pos 0, char b is at pos 2, int c is at pos 4
```

可以发现，这个结构体并不是简单地将一个2字节的`a`、一个1字节的`b`和一个4字节的`c`合并在一起变成7字节的结构体，而是在`b`字段后补了一个1字节的padding。

从某种意义上来说，这也是因为数据对齐。试想，如果我们想不产生性能损耗，那么，`a`的地址应该以2字节对齐，`b`的地址应该以1字节对齐，`c`的地址应该以4字节对齐。那么，使用一个非常简单的想法，就是`b`后补1个字节，这样就能同时保证这三点了。

这从某种意义上说，也是各种网络报文，例如IP报文头（如下图，改编自[IETF的RFC791](https://datatracker.ietf.org/doc/html/rfc791)）如此规整的原因。

```plaintext
 0               1               2               3
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

## 寻址模式

接下来，我们就讲一讲，`[mem_addr]`部分是怎么构成的，也就是所谓的「寻址模式」（Addressing Mode）。

### 仅基寄存器

首先最直接的，我们可以直接将地址存储在寄存器中，访问内存时先去寄存器中查找相应的地址。例如：

```armasm
ldr    w1, [x0]
```

就是指将`x0`中存储的值看作一个内存地址，向相应的内存地址中取值，赋值到`w1`中。

这种模式我们在C语言中非常常见，可以理解成C语言中的指针。`b = *a`就是将`a`的值看作地址，向内存地址中取值，赋值给`b`。

### 基寄存器加偏移

仅基寄存器模式已经可以实现绝大部分的内存交互方式了。但是，在用C语言等高级语言编程的时候，会有一些非常常用的代码模式。针对这些代码模式，在底层汇编指令中也做了相应的优化。

#### 基寄存器加常数偏移

在C语言中，我们常常会有对结构体字段的访问：

```c
struct Foo {
    int a;
    int b;
};

struct Foo *foo = get_foo_ptr();
// accessing foo->b
// ...
```

例如，像这个程序一样，我们有一个`Foo`结构体指针`foo`，我们想访问其`b`字段（在底层而言，其偏移为4字节），那么，我们需要将`foo`指针指向的地址加4，然后解引用，就可以得到`foo->b`了。

这种对结构体字段的访问，在底层往往就是「将寄存器存储的地址加上一个常数，再读/写相应的地址」。为了优化这种模式，我们的寻址模式中就有基寄存器加常数偏移这种模式：

```armasm
ldr    w1, [x0, #4]
```

上述指令的意思就是，将`x0`寄存器的值加4，看作一个地址，对其访问，取值并赋值给`w1`。

这种模式除了方便结构体字段的访问，也方便局部变量的访问。不过这章中我们暂时不介绍局部变量，在之后函数的章节会完整介绍。

#### 基寄存器加寄存器偏移

在C语言中，我们往往会有对数组的遍历：

```c
char a[64];
for (size_t i = 0; i < 64; i++) {
    char b = a[i];
    // ...
}
```

我们可以发现，`a`和`i`都是变量，我们在翻译成汇编语言的过程中，可以都使用寄存器存储这两个变量。在这种模式下，我们需要将存储`a`的值的寄存器和存储`i`的寄存器的值相加，看作一个地址，对其读/写。针对这种情况，汇编语言层面我们可以用：

```armasm
ldr    w2, [x0, x1]
```

表示将`x0`的值与`x1`的值相加，看作一个地址，取值并赋值给`w2`。

有一点值得注意：我们上面的例子中，`a`是一个`char`类型的数组。这意味着，这个数组的第几个元素，就是与首地址距离几个字节。例如，`a[2]`与首地址`a`就确实距离2字节。但是，如果是别的类型的数组呢？

对于整型数组`int a[64]`，一个整型的长度是4个字节，那么`a[2]`就与首地址距离8个字节。对于这种情况，我们可以用到在[基本的数据处理指令](./9-基本的数据处理指令.md)一章中提到的「操作数的可选移位」实现：

```armasm
ldr    w2, [x0, x1, lsl #2]
```

上述指令是指，将`x0`的值，与`x1`左移2位后的值相加，看作地址，取值并赋值给`w2`。我们之前提到过，左移两位就是乘以4，所以这个指令就可以完美地模拟整型数组的遍历。

### 索引寻址

索引寻址可以用于一些更特殊的代码模式：

```c
int *a;
int b = *(++a);
int c = *(a++);
```

* 对于第二行`b`的赋值而言，我们需要将`a`的值加4（`int`类型宽度为4）后赋值给`a`，然后取值赋值
* 对于第三行`c`的赋值而言，我们需要将`a`取值赋值，然后将`a`的值加4（`int`类型宽度为4）后赋值给`a`

对于这两种代码模式，我们可以分别用：

```armasm
ldr    w1, [x0, #4]!
ldr    w1, [x0], #4
```

这两种写法。

* 第一种写法被称为前索引寻址，将`x0`的值加4赋值给`x0`后，将对应内存取值赋值给`w1`
* 第二种写法被称为后索引寻址，将`x0`对应的内存取值赋值给`w1`后，将`x0`自身值加4赋值给自身

这两种索引寻址模式往往在程序优化中会使用，可以在LLVM源码中搜索`AArch64LoadStoreOpt::mergeUpdateInsn`这个函数，看看会有哪些优化可以使用这两种寻址模式。

### 字面量寻址

在[赋值指令](./8-赋值指令.md)一章中我们提到过，如果在使用`ldr`伪指令的时候，相应的数无法在`mov`指令中表示，那么汇编器将在二进制镜像中创建一块内存区域存储相应的值，在执行时通过读取内存的方式进行赋值。

在这里，读取内存就是通过字面量寻址的方式。在编码时，计算目标内存地址与当前指令地址的距离，在执行时，通过当前程序计数器PC加上相应的距离就可以得到相应的地址。
