# 汇编、链接与调试

在这一章中，我们主要介绍的是汇编、链接与调试的全过程的原理。

## 汇编与链接

在[第一个汇编程序](./5-第一个汇编程序.md)中，我们介绍了怎样由汇编代码生成可执行程序。它主要包括两个阶段：

汇编：

```bash
as foo.s -o foo.o
```

链接：

```bash
ld foo.o -lSystem -L `xcrun --show-sdk-path -sdk macosx`/usr/lib -o foo
```

在汇编程序生成可执行程序的过程中，为什么需要分为汇编和链接两步呢？这两步分别是做什么的呢？

在Unix刚刚发明的时代，开发者在编写软件时有一个理念：一个程序只做一件事。在这里，汇编器的作用实际上是将汇编代码`foo.s`转化为机器指令，生成的`foo.o`被称为目标文件（Object file），其中包含的大部分机器指令实际上和可执行程序`foo`中包含的一样。也就是说，`foo.o`中也存在`__text`节，也存在`__data`节。但是，我们知道，在编写实际的大型软件的过程中，几乎不存在所有代码都在一个文件中的情况。往往一个大型项目会包含许多项目源文件。那么汇编器将每一个源文件都翻译为存储有相应机器指令的目标文件，可是最终的可执行文件只有一个，所以这里就需要链接器。链接器分析每一个目标文件的相应的段和节，将其提取、拼接，最终生成一个可执行文件。

这就是汇编和链接的一个大致的过程，汇编将汇编语句翻译为机器指令，链接将多个目标文件合并为一个可执行程序。但是，这其中实际上还有非常多的问题，我们将在这章中解释。

这章的例子包含三个文件：[codes/14-foo1.s](https://github.com/Evian-Zhang/learn-assembly-on-Apple-Silicon-Mac/blob/master/codes/14-foo1.s)、[codes/14-foo2.s](https://github.com/Evian-Zhang/learn-assembly-on-Apple-Silicon-Mac/blob/master/codes/14-foo2.s)和[codes/14-main.s](https://github.com/Evian-Zhang/learn-assembly-on-Apple-Silicon-Mac/blob/master/codes/14-main.s)。前两者分别定义了函数`bar1`和`bar2`，这两个函数分别会输出"This is bar1 in foo1"和"This is bar2 in foo2"。在main中调用了这两个函数。

## 静态链接与动态链接

### 静态链接

刚刚我们提到，链接器可以将多个目标文件合并生成一个可执行程序。在实际软件开发的过程中，我们往往会用到别人编写的库，我们也有可能自己编写一个库，给别人使用。那么，按照上面的逻辑，我们编写的库实际上也可以看作一种特殊的“目标文件”，在给别人使用的过程中，别人通过链接器，将我们使用的库一起组合生成一个可执行文件。这就是「静态链接」的概念。

具体而言，针对本章的例子，我们使用汇编器将`14-foo1.s`和`14-foo2.s`分别翻译为对应的目标文件`14-foo1.o`和`14-foo2.o`之后，可以使用

```bash
ar rcs lib14-foo-static.a 14-foo1.o 14-foo2.o
```

这个命令会将刚刚生成的这两个目标文件合并为静态库`lib14-foo-static.a`。

我们在`14-main.s`中使用了这个库，所以在把它翻译为`14-main.o`之后，我们要在链接时把这个库一块儿链接上：

```bash
ld -L. 14-main.o -l14-foo-static -lSystem -L `xcrun --show-sdk-path -sdk macosx`/usr/lib -o 14-main-static
```

可以发现，它主要多了`-L.`和`-l14-foo-static`这两个选项。`-l14-foo-static`选项会使链接器在搜索路径下搜索`lib14-foo-static.a`文件，找到后一起链接；`-L.`则将当前目录添加到搜索路径下，使链接器可以找到我们刚刚生成的静态库。

对于这种静态链接生成的程序，我们可以使用

```bash
objdump -D 14-main-static
```

反汇编。通过反汇编，我们可以发现，静态链接就是直接把库的代码放到可执行程序中，我们在`14-main-static`这个可执行程序中找到了`bar1`和`bar2`的代码。

### 动态链接

我们在使用静态链接的过程中，往往会发现一些问题：

* 重复的库占用内存、硬盘

   有些库非常常用，许多开发者写的程序都需要这些库。如果这些库本身的体积很大，而静态链接会把这个库链接到每一个程序中，就会导致这些程序都存在极为庞大的重复代码。无论是存储在硬盘中，还是载入到内存里，都会占用很大的空间。我们自己写的库有可能很小，只有几KB，但是像Electron这种大型的GUI框架，也有不少人吐槽其体积问题（[electron/electron #673](https://github.com/electron/electron/issues/673)）。
* 更新困难

   如果想要给用户更新自己编写的程序，那么最简单的方法就是把新编译的程序替换旧编译的程序。可是对于大型的应用来说，一次更新就需要用户下载几百M甚至几个G的内容，会很麻烦。


针对这些问题，我们拥有了动态链接技术。不过这里要指出，动态链接并不是一定比静态链接好。只是针对不同的情况，可以采取不同的策略。

动态链接的思想也很直接：我们将库变成独立的动态链接库，不再直接放到可执行程序里。如果多个程序用到了同一份库，那我们只需要一个动态链接库就行，让多个程序链接这个库。在更新软件时，如果需要更新的内容是动态链接库里的，那就直接把更新的动态链接库发送给用户，不需要改主程序。

具体而言，我们得到目标文件`14-foo1.o`和`14-foo2.o`之后，将其链接为动态链接库：

```bash
ld 14-foo1.o 14-foo2.o -lSystem -L `xcrun --show-sdk-path -sdk macosx`/usr/lib -dylib -o lib14-foo-dynamic.dylib
```

也就是说，在链接时增加`-dylib`选项。

在生成最终可执行程序时，和静态链接类似：

```bash
ld -L. 14-main.o -l14-foo-dynamic -lSystem -L `xcrun --show-sdk-path -sdk macosx`/usr/lib -o 14-main-dynamic
```

同样是加`-L.`和`-l14-foo-dynamic`，这个`-l`选项会同时搜索`.a`和`.dylib`。

值得指出的是，正如静态链接和动态链接的名字所指示的，静态链接就是在编译时将库的代码直接放到可执行程序内部，而动态链接是在执行可执行程序的过程中，将动态链接库载入内存。如果有多个程序动态链接到了同一个库，那么在载入这些程序到内存的过程中，会将动态链接库所在的同一张物理页映射到这些程序的进程空间中。也就是说，这些进程的内存空间实际上有共同的一部分物理内存，这部分就是动态链接库所在的物理页。这种方式就可以减小内存占用，同时也是一些现代的处理器层面的攻击手段（如熔断、幽灵漏洞等）得以攻击的途径。

### 静态链接程序与动态链接程序

与静态链接（static linking）、动态链接（dynamic linking）这种链接的方式对应的，也有静态链接的程序（statically-linked binary）与动态链接的程序（dynamically-linked binary）。静态链接的程序就是指不依赖任何动态链接库的程序，其余的程序则是动态链接的程序。

我们平常编写的程序都是动态链接的程序。一个最普通的Hello world的程序，依赖什么动态库呢？最主要的，还是依赖libc。之前我们提到，大部分常用的系统调用都有libc的封装，而我们常用的一些C语言的库函数如`strlen`、`fopen`等，也都是由libc提供。我们在链接时加上的`-lSystem`实际上就是表明我们的程序动态依赖libc库。

macOS一般不支持静态链接的程序。在理论上，静态链接的汇编程序及C程序实际上是需要startup codes的，一般被称为C Runtime，简写为crt。crt是用来做什么的呢？我们知道，`main`函数可以用参数：

```c
int main(int argc, char **argv);
```

这些参数承载命令汗参数相关的信息。这些参数的传递实际上就是由crt处理的。除此之外，crt也负责TLS的初始化等工作。因此，在汇编层面来看，静态链接的程序的开始并不是`main`函数，而是crt的开始，一般为`start`函数。我们可以简单看一下在Linux系统上，`start`函数是怎么调用`main`函数的：

对于glibc来说，我们可以在`sysdeps/generic/libc_start_call_main.h`文件中看到：

```c
_Noreturn static __always_inline void
__libc_start_call_main (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
                        int argc, char **argv MAIN_AUXVEC_DECL)
{
  exit (main (argc, argv, __environ MAIN_AUXVEC_PARAM));
}
```

类似地，对于LLVM提供的libc来说，我们可以在`libc/loader/linux/x86_64/start.cpp`文件中看到：

```c
extern "C" void _start() {
  // ...
  __llvm_libc::syscall(SYS_exit,
                       main(args->argc, reinterpret_cast<char **>(args->argv),
                            reinterpret_cast<char **>(env_ptr)));
}
```

在将命令行参数传递给`main`函数之后，使用其返回值作为`exit`的参数进行退出。

## 调试

除了汇编、链接之外，与我们开发软件息息相关的就是调试技术了。所谓的调试，就是使用调试器监控进程的运行，可以设置断点、单步调试等等。

对于本章的例子，我们在生成`14-main-static`可执行程序之后，可以使用LLDB对其进行调试：

```bash
lldb ./14-main-static
```

我们可以首先使用

```bash
(lldb) breakpoint set --name main
```

设置断点。

然后使用

```bash
(lldb) run
```

运行程序。

当程序执行到`main`函数开头的时候，就会自动暂停：

![breakpoint](./assets/14-lldb-breakpoint.png)

随后，我们可以使用

```bash
(lldb) register read
```

查看此时所有寄存器的值。我们也可以使用别的指令进行别的运行时操作。

最后，使用<kbd>ctrl</kbd>+<kbd>D</kbd>退出LLDB。

那么，调试是怎么实现的呢？我们首先来看看调试时设置断点的过程：

1. 调试器进程对被调试进程特定指令地址设置断点
2. 被调试进程执行到断点时，暂停执行
3. 控制权交还调试器进程

在操作系统层面，这个是由`ptrace`系统调用实现的。调试器进程通过这个系统调用，告诉内核被调试的进程，以及一个中断信号。如果被调试进程发出该中断信号，则内核将控制权交给调试器进程。

那如何使被调试进程发出中断信号呢？这需要从处理器层面进行考虑。[官方文档](https://developer.arm.com/documentation/102140/0200/Breakpoints)中一共给出了两种方案：

* 软件断点

   被调试进程在断点位置的指令被替换为`bkpt`指令。当执行到该指令时，会发出特定的中断信号。
* 硬件断点

   AArch64架构有若干硬件调试寄存器。当执行的指令满足某些设定的条件时（如指令地址等于存储在调试寄存器中的值），发出特定的中断信号。
