# 赋值指令

接下来几章将介绍A64指令集的一些基本指令操作。

首先我们来了解一下有哪些给寄存器赋值的指令。向寄存器赋值，理论上主要由三种方式：用常数给寄存器赋值、用另一个寄存器的值给寄存器赋值、用内存里的值给寄存器赋值。这里主要介绍前两者，关于从内存向寄存器赋值的一系列与内存交互的指令将在后续的章节统一介绍。

## 将一个寄存器的值赋值给另一个寄存器

这个过程非常简单，主要就是`mov`指令。

### 同宽度赋值

例如，`mov    w0, w1`可以将`w1`的值赋值给`w0`；`mov    x0, x1`可以将`x1`赋值给`x0`。

但值得注意的是，这些指令都只能在同样宽度的寄存器之间赋值。也就是说，我们不能通过`mov`指令，直接将`x0`的值赋给`w1`。这是为什么呢？

这是因为，在不同宽度寄存器之间的赋值，需要考虑扩展与截断的问题。

### 扩展

在[底层的整数](./1-底层的整数.md)一章中，我们讲到，在寄存器存储数的过程中，既可以把存储的值看作有符号整数，也可以把存储的值看作无符号整数。如果将寄存器存储的值看作无符号整数，那在不同宽度寄存器之间的赋值是非常简单且直接的。但是，如果把寄存器存储的值看作有符号整数，问题就变得复杂了起来。

假设我们`w0`寄存器存储的值为`0xFFFFFFFD`。如果想要将`w0`寄存器赋值给`x1`寄存器，我们想得到的结果是怎样的呢？

* 如果将`w0`寄存器存储的值看作无符号整数，则其存储的是十进制数4294967293。赋值给`x1`后，其同样也应该存储这个十进制数，因此`x1`寄存器存储的值应该是`0x00000000FFFFFFFD`。
* 如果将`w0`寄存器存储的值看作有符号整数，则其存储的是十进制数-3。赋值给`x1`后，其存储的同样也应该是`-3`。因此`x1`寄存器存储的值应该是`0xFFFFFFFFFFFFFFFD`。

根据上面的讨论，我们在从小宽度寄存器赋值给大宽度寄存器时，应当考虑其存储的数的意义。这种操作被称为**扩展**（Extension）。因此，AArch64架构下我们主要有两种扩展操作：有符号扩展`sxt`与无符号扩展`uxt`：

* 无符号扩展非常好理解，就是将源寄存器直接赋值给目的寄存器相应的部分，剩余的高位使用`0`进行填充。
* 有符号扩展则是，将源寄存器赋值给目的寄存器相应的部分，剩余的高位使用源寄存器的最高位进行填充。例如，`0xFFFFFFFD`二进制情况下最高位为`1`，因此剩余的高位将都用`1`进行填充。这种方式有效保证了源寄存器与目的寄存器的值，在有符号整数的意义下，符号和绝对值都是相同的。

这两类指令分别提供了三个指令供我们使用：`sxtb`、`sxth`、`sxtw`与`uxtb`、`uxth`、`uxtw`。

* 以`b`结尾的指令

   `b`代表byte。这类指令将源寄存器的最低位的一个字节赋值给目的寄存器，并进行相应的扩展。
* 以`h`结尾的指令

   `h`代表halfword。这类指令将源寄存器的最低位的两个字节赋值给目的寄存器，并进行相应的扩展。
* 以`w`结尾的指令

   `w`代表word。这类指令将源寄存器的最低位的四个字节赋值给目的寄存器，并进行相应的扩展。

根据这种描述，我们可以轻松推断出，这类指令的源操作数必须是32位寄存器，而目的操作数则可以是64位寄存器，也可以是32位寄存器（以`w`结尾的指令除外）。

官方教程中的这张图可以直观地理解这些指令：

### 截断

截断就是指，从大宽度的寄存器向小宽度的寄存器赋值。这一过程比较粗暴，就是直接将相应的部分赋值即可，不考虑任何符号因素。例如，如果想将`x0`的值赋值给`w1`，我们需要做的就是使用`mov    w0, w1`，也就是不考虑其高位，也不考虑其符号。

## 将常数赋值给寄存器

这个问题乍看起来非常简单呀，和寄存器给寄存器赋值操作应该很类似才对。然而，由于AArch64架构的原因，这个问题变得复杂起来。

我们知道，AArch64是定长指令集架构，其所有的指令在二进制层面长度都是32位。那么，我们怎样才能在定长指令集中编码这种常数赋值呢？如果是32位常数，肯定无法编码，因为指令总共长度才32位，至少还需要几位编码操作码与目的操作数吧。
