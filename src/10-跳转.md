# 跳转

在我们日常编程的过程中，控制流的跳转是不可或缺的，如`if`-`else`语句、`while`和`for`循环等。这一类语句是怎样在汇编层面实现的呢？

## 标签

在介绍几种汇编层面的跳转之前，我们首先需要知道标签的概念。我们之前接触到的`_main:`就是一个标签。

在汇编语言中，标签往往不进行缩进，同时以`:`结尾。标签的作用是标记当前的地址。例如，我们最开始的汇编程序

```armasm
# 5-basic.s
    .section    __TEXT,__text
    .globl  _main
    .p2align    2
_main:
    mov    w0, #0
    ret
```

这个汇编程序中，`_main`标签标记了`mov    w0, #0`这条指令的地址，在接下来的任何指令中，如果用到`_main`这个标签（例如，跳转到`_main`标签所标记的位置。使用方法随后就会介绍），汇编器就会使用其地址来代替。

值得注意的是，这里使用了PC-relative的技巧。在[操作系统](./4-操作系统.md)一章中我们提到，为了充分随机化进程中的地址，我们需要编写Position-Independent Code。这里面要求，所有的指令不能涉及绝对地址。那么，如果直接将标签替换为相对应的绝对地址，是不满足PIC的要求的。所以如何处理我们的标签，才能正确编码相应的跳转指令，使得程序中不含有绝对地址呢？

我们可以注意到一件事，虽然一个进程在内存中的栈、堆、代码段等的基地址产生了随机化，但是其内部是不可以随机化的。例如，在代码段里，一条指令长32位。那么在执行这条指令时，`pc`寄存器的值加4，就一定是下一条指令的地址。也就是说，指令之间地址的距离是保持不变的。因此，我们可以使用「这个标签标记的位置距离这条指令的距离」来编码这个标签。这就是PC-relative的地址编码。

例如，有一条跳转指令，它的跳转目标是其之前的3条指令所在的位置（一条指令长32位），那么PC-relative的编码方式就可以是-12。

## 无条件直接跳转

所谓的无条件跳转，就是指执行这条语句后，控制流总是会前往指定的地方。C语言中的`goto`是一个比较直接的无条件直接跳转。在A64指令集中，无条件直接跳转使用`b`指令来表示。

例如，我们有以下汇编程序：

```armasm
foo:
    add    w0, w0, #1
    b      foo
```

那么这个程序就会陷入一个死循环，不断地给`w0`寄存器里的值加1。

我们在日常编程的过程中，什么时候会比较常用到这种无条件跳转呢？答案是在`switch`语句中。

考虑下面这个C语言程序片段：

```c
switch (a) {
    case 0: /* do something A */ break;
    case 1: /* do something B */ break;
}
// do something C
```

先不考虑`switch`本身的跳转怎么实现的，我们来看看`switch`之后的`break`该如何实现：

```armasm
    ; Decide whether do something A, B or C by a's value
zero_case:
    ; Do something A
    b    after_switch
one_case:
    ; Do something B
    b    after_switch
after_switch:
    ; Do something C
```

使用无条件直接跳转来实现`break`语句是一个很直观的想法。

## PSTATE

在介绍条件跳转之前，我们首先需要了解AArch64的PSTATE机制。

在之前介绍基本的算术指令时，我们忽视了一个很重要的事：溢出。在[底层的整数](./1-底层的整数.md)中我们提到，溢出是一个很严重的事情。因此，我们需要知道，我们进行的这个算术运算，会不会产生溢出。

我们在实现条件跳转的时候，也会思考，我们选择性跳转所依赖的「条件」，究竟可以是哪些条件？事实上，无外乎大于、小于等等。而这种大于小于的比较，我们也可以转化为一个算术运算：将两数相减，看结果是大于0，还是小于0。

因此，在我们进行算术运算的过程中，一些结果的“状态”对我们的编程是有意义的。这些状态，如是否溢出、是否小于0等，都是只有「是」或「否」两种可能。用来表示这种状态的，就是PSTATE机制。

在AArch64架构中，PSTATE（Process State）一种进程状态信息（Process State, PSTATE）。PSTATE存储了当前进程的状态，例如当前的异常级别、安全级别等等。此外，PSTATE还存储了一些条件位（Conditional Flags），其中包括：

* N位

   1表示结果为负，0表示结果非负
* Z位

   1表示结果为零，0表示结果非零
* C位

   1表示结果有进位，0表示结果无进位
* V位

   1表示结果有溢出，0表示结果无溢出

这些概念很抽象，那我们实际的指令是如何影响PSTATE的呢？

事实上，我们之前所讲的算术指令一般是默认不影响PSTATE的。这事因为大部分的算术指令的执行，并不会作为后续条件跳转的条件，从而可以节约计算成本。而如果我们需要使用可以影响PSTATE的指令，则需要在后面加上一个`s`。

例如，`adds`是`add`的一个变种，可以影响PSTATE。当结果相加为0，则会设立Z位。

但是，这些结尾加`s`的指令，从某种意义上讲，是「有副作用」的指令。因为这些指令，都需要一个目的操作数。也就是说，其需要将运算结果存储在目的寄存器中。但是，在大部分情况下，我们高级语言编写条件语句时，都仅仅是作一个大小的比较，并不需要得到实际的结果。因此，AArch64架构提供了更符合开发者语义的指令：`cmp`和`tst`。

`cmp    a, b`指令是`subs    wzr, a, b`的别名。也就是说，`cmp`指令将两数直接相减，并且不存储其相减的结果，同时设置PSTATE位。这就是最常见的比较指令。

`tst    a, b`指令是`ands    wzr, a, b`的别名。也就是说，`tst`指令将两数逐位相与，并设置PSTATE位。设计这个指令的目的是因为，在高级语言中，有非常非常多判断一个值是否为0的操作。与使用`cmp`，也就是减去0相比，更巧妙的方法是将这个值与自身相与，也就是`tst    a, a`。那么，这个值为0，当且仅当与自身相与的结果为0。
